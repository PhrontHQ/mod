/**
 * @module "mod/ui/succession.mod"
 */
var Component = require("ui/component").Component;

/**
 * Subclasses Component for its `domContent` behavior.
 *
 * If passage properties are defined on the Succession, they will override children's.
 * See {@link Succession#_prepareComponentsForBuild}.
 *
 * @class Succession
 * @augments Component
 */
exports.Succession = Component.specialize(/** @lends Succession.prototype */{

    contentBuildInAnimation: {
        value: undefined
    },

    contentBuildOutAnimation: {
        value: undefined
    },

    /**
     * Setting content to a component will add the component to `history`.
     * Setting content to null will clear `history`.
     */
    content: {
        get: function () {
            return this.history.length ? this.history[this.history.length - 1] : undefined;
        },
        set: function (component) {
            if (component) {
                this.history.push(component);
            } else {
                this.history.clear();
            }
        }
    },

    _firstComponent: {
        value: undefined
    },

    _history: {
        value: undefined
    },

    /**
     * A stack consisted of {@link Component}s.
     *
     * @property {Array}
     */
    history: {
        get: function () {
            if (!this._history) {
                this._history = [];
                this._history.addBeforeRangeChangeListener(this);
                this._history.addRangeChangeListener(this);
            }
            return this._history;
        },
        set: function (history) {
            history = Array.isArray(history) ? history : [];
            if (this.history !== history) {
                if (!this.history.length && history.length) {
                    this._firstComponent = history[0];
                }
                this.history.splice.apply(this.history, [0, this.history.length].concat(history));
            }
        }
    },

    /**
     * @property {boolean}
     * @default false
     */
    hasTemplate: {
        enumerable: false,
        value: false
    },

    /**
     * Override build-in / out animation; checks for whether properties are undefined,
     * as null is used to disable passage animation.
     *
     * Priority from most important: Succession -> Passage -> Component
     *
     * @private
     * @function
     */
    _prepareComponentForBuild: {
        value: function (component) {
            if (component) {
                if (this.contentBuildInAnimation) {
                    component.buildInAnimationOverride = this.contentBuildInAnimation;
                }

                if (this.contentBuildOutAnimation) {
                    component.buildOutAnimationOverride = this.contentBuildOutAnimation;
                }
            }
        }
    },

    _prepareComponentsForBuild: {
        value: function (components = []) {
            components.forEach(this._prepareComponentForBuild, this);
        }
    },

    /**
     * Ensure components generated by instantiating in JavaScript instead of
     * declaring in template serialization has an element.
     *
     * @private
     * @function
     * @param {Component} content
     */
    _updateDomContentWith: {
        value: function (content) {
            if (content) {
                var element;
                if (!content.element) {
                    element = document.createElement("div");
                    element.id = content.identifier || "appendDiv";
                    content.element = element;
                } else {
                    element = content.element;
                }
                this.domContent = element;
                content.needsDraw = true;
            } else {
                this.domContent = null;
            }
        }
    },

    _isTransitioning: {
        value: false
    },

    /**
     * Whether the Succession is transitioning between history changes.
     * @property {boolean}
     * @default false
     * @readonly
     */
    isTransitioning: {
        get: function () {
            return this._isTransitioning;
        }
    },

    _transitioningPromise: {
        value: null
    },

    /**
     * A promise that resolves when the Succession is done transitioning.
     * @property {Promise}
     * @readonly
     */
    transitioningPromise: {
        get: function () {
            return this._transitioningPromise;
        }
    },

    _transitioningPromiseResolver: {
        value: null,
        writable: true
    },

    /**
     * Updates the transitioning status of the Succession.
     * @param {boolean} value - The new transitioning status.
     * @throws {TypeError} If the value is not a boolean.
     * @private
     */
    _setTransitioningStatus: {
        value: function (value) {
            if (typeof value !== "boolean") {
                throw new TypeError("Transitioning status must be a boolean.");
            }

            if (value !== this._isTransitioning) {
                this.dispatchBeforeOwnPropertyChange("isTransitioning", this._isTransitioning);
                this._isTransitioning = value;
                this.dispatchOwnPropertyChange("isTransitioning", value);

                // Update the transitioning promise.
                this.dispatchBeforeOwnPropertyChange("transitioningPromise", this._transitioningPromise);

                if (!value && this._transitioningPromise) {
                    this._transitioningPromiseResolver();
                    this._transitioningPromiseResolver = null;
                    this._transitioningPromise = null;
                } else {
                    this._transitioningPromise = new Promise(resolve => {
                        this._transitioningPromiseResolver = resolve;
                    });
                }

                this.dispatchOwnPropertyChange("transitioningPromise", this._transitioningPromise);
            }
        }
    },

    /**
     * Checks if any component in history is transitioning and updates the transitioning status.
     * @private
     */
    _checkTransitioningStatus: {
        value: function () {
            if (this._isTransitioning) {
                this._setTransitioningStatus(this._isAnyComponentInTransition());
            }
        }
    },

    /**
     * Checks if any component in history is transitioning.
     * @private
     */
    _isAnyComponentInTransition: {
        value: function () {
            return this.history.some(({ currentBuildAnimation }) => !!currentBuildAnimation);
        }
    },

    /**
     * Checks if any component in the given children has animations (build-in or build-out).
     * @private
     */
    _hasComponentsWithAnimations: {
        value: function (children = this.history) {
            return children.some(({
                buildOutAnimationOverride,
                buildInAnimationOverride,
                buildOutAnimation,
                buildInAnimation,
             }) => {
                if (buildOutAnimationOverride) buildOutAnimation = buildOutAnimationOverride;
                if (buildInAnimationOverride) buildInAnimation = buildInAnimationOverride;

                return (
                    this._isAnimationDefinedAndNonEmpty(buildOutAnimation) ||
                    this._isAnimationDefinedAndNonEmpty(buildInAnimation)
                );
            });
        }
    },

    /**
     * Checks if an animation is defined and non-empty.
     * @private
     */
    _isAnimationDefinedAndNonEmpty: {
        value: function (animation) {
            return !!(animation && Object.keys(animation).length > 0);
        }
    },

    // =============================================================================================
    // Event Handlers
    // =============================================================================================

    /**
     * Prepare outgoing content; need to prepare before range actually changes because we need to
     * prepare on outgoing content and handleRangeChange happens after outgoing content is gone
     */
    handleRangeWillChange: {
        value: function (plus, minus, index) {
            this._prepareComponentForBuild(this.content);
        }
    },

    /**
     * Sets classes on Succession depending on how history was changed
     * Prepare incoming content
     */
    handleRangeChange: {
        value: function (plus, minus, index) {
            //console.log(this.content && this.content.title);
            //console.log(plus[0] && plus[0].title);
            //console.log(minus[0] && minus[0].title);
            var length = this.history ? this.history.length : 0,
                isChanged = plus.length || minus.length,
                isChangeVisible = isChanged && index + plus.length === length,
                isPush = isChangeVisible && !minus.length && index,
                isPop = isChangeVisible && !plus.length && length,
                isReplace = isChangeVisible && !isPush && !isPop && length,
                isClear = isChangeVisible && !length;
            // Set appropriate classes and update the succession if necessary.
            if (isChangeVisible) {
                this.classList[isPush ? "add" : "remove"]("mod-Succession--push");
                this.classList[isPop ? "add" : "remove"]("mod-Succession--pop");
                this.classList[isReplace ? "add" : "remove"]("mod-Succession--replace");
                this.classList[isClear ? "add" : "remove"]("mod-Succession--clear");
                this._prepareComponentForBuild(this.content);

                // Update the Succession's content.
                this.dispatchBeforeOwnPropertyChange("content", this.content);
                this._updateDomContentWith(this.content);
                this.dispatchOwnPropertyChange("content", this.content);

                const affectedComponents = [...plus, ...minus];

                // As we only prepare the incoming and outgoing components for build and if there are multiple affected
                // components (e.g., during a complex history change, like a `clear()`), we need to ensure that all
                // components in between are also prepared for build. This guarantees that animation overrides are
                // applied consistently across all relevant components.
                if (affectedComponents.length > 1) {
                    this._prepareComponentsForBuild(affectedComponents);
                }

                // Let's determine if the Succession should be marked as transitioning.
                let hasComponentsWithAnimations = this._hasComponentsWithAnimations(affectedComponents);
                this._setTransitioningStatus(hasComponentsWithAnimations);
            }
        }
    },

    handleBuildInEnd: {
        value: function (event) {
            this._checkTransitioningStatus();
            this.needsCssClassCleanup = true;
            this.needsDraw = true;
        }
    },

    handleBuildOutEnd: {
        value: function (event) {
            this._checkTransitioningStatus();
            this.needsCssClassCleanup = true;
            this.needsDraw = true;
        }
    },

    // =============================================================================================
    // Life Cycle Hooks
    // =============================================================================================

    /**
     * The first time, extract the argument component (if any) and insert it into the succession
     * without animation. Must wait for argument component's template to be expanded as
     * parent replaces template with component's element.
     *
     * TODO: Component's extractDomArgument("*") does not seem to be working so the
     *       content argument must explicitly be named "content".
     */
    enterDocument: {
        value: function (isFirstTime) {
            var contentElement = isFirstTime && this.extractDomArgument("content"),
                contentComponent = contentElement && contentElement.component,
                self = this;
            if (contentComponent) {
                contentComponent.expandComponent().then(function () {
                    self.history.push(contentComponent);
                });
            }
            if (isFirstTime) {
                this.addEventListener("buildInEnd", this);
                this.addEventListener("buildOutEnd", this);
            }
        }
    },

    draw: {
        value: function () {
            if (this.needsCssClassCleanup) {
                this.needsCssClassCleanup = false;
                this.classList.deleteEach([
                    "mod-Succession--push",
                    "mod-Succession--pop",
                    "mod-Succession--replace",
                    "mod-Succession--clear"
                ]);
            }
        }
    }

});
